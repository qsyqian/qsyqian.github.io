<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>qianshuangyang  | Flannel源码分析</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.59.1" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.d98f2eb6bcd1eaedb7edf166bd16af26.css" rel="stylesheet">
    

    

    
      
    

    
    
    <meta property="og:title" content="Flannel源码分析" />
<meta property="og:description" content="Flannel源码分析 前言 flannel作为kubernetes的一种网络解决方案，在社区是比较活跃的。支持多种backend。
flannel源码地址在：https://github.com/coreos/flannel
从官网上把flannel的代码clone下来，目录结构如下：
$ ll -ah total 222K drwxr-xr-x 1 user 197121 0 8月 30 18:37 ./ drwxr-xr-x 1 user 197121 0 8月 30 18:31 ../ -rw-r--r-- 1 user 197121 351 8月 30 18:33 .appveyor.yml -rw-r--r-- 1 user 197121 56 8月 30 18:33 .dockerignore drwxr-xr-x 1 user 197121 0 9月 17 09:34 .git/ drwxr-xr-x 1 user 197121 0 8月 30 18:33 .github/ -rw-r--r-- 1 user 197121 147 8月 30 18:33 ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://qsyqian.github.io/post/flannel-source-code-analysis/" />
<meta property="article:published_time" content="2019-09-12T16:59:05+08:00" />
<meta property="article:modified_time" content="2019-09-12T16:59:05+08:00" />
<meta itemprop="name" content="Flannel源码分析">
<meta itemprop="description" content="Flannel源码分析 前言 flannel作为kubernetes的一种网络解决方案，在社区是比较活跃的。支持多种backend。
flannel源码地址在：https://github.com/coreos/flannel
从官网上把flannel的代码clone下来，目录结构如下：
$ ll -ah total 222K drwxr-xr-x 1 user 197121 0 8月 30 18:37 ./ drwxr-xr-x 1 user 197121 0 8月 30 18:31 ../ -rw-r--r-- 1 user 197121 351 8月 30 18:33 .appveyor.yml -rw-r--r-- 1 user 197121 56 8月 30 18:33 .dockerignore drwxr-xr-x 1 user 197121 0 9月 17 09:34 .git/ drwxr-xr-x 1 user 197121 0 8月 30 18:33 .github/ -rw-r--r-- 1 user 197121 147 8月 30 18:33 .">


<meta itemprop="datePublished" content="2019-09-12T16:59:05&#43;08:00" />
<meta itemprop="dateModified" content="2019-09-12T16:59:05&#43;08:00" />
<meta itemprop="wordCount" content="2172">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Flannel源码分析"/>
<meta name="twitter:description" content="Flannel源码分析 前言 flannel作为kubernetes的一种网络解决方案，在社区是比较活跃的。支持多种backend。
flannel源码地址在：https://github.com/coreos/flannel
从官网上把flannel的代码clone下来，目录结构如下：
$ ll -ah total 222K drwxr-xr-x 1 user 197121 0 8月 30 18:37 ./ drwxr-xr-x 1 user 197121 0 8月 30 18:31 ../ -rw-r--r-- 1 user 197121 351 8月 30 18:33 .appveyor.yml -rw-r--r-- 1 user 197121 56 8月 30 18:33 .dockerignore drwxr-xr-x 1 user 197121 0 9月 17 09:34 .git/ drwxr-xr-x 1 user 197121 0 8月 30 18:33 .github/ -rw-r--r-- 1 user 197121 147 8月 30 18:33 ."/>

  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="https://qsyqian.github.io/" class="f3 fw2 hover-white no-underline white-90 dib">
      qianshuangyang
    </a>
    <div class="flex-l items-center">
      

      
        <ul class="pl0 mr3">
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/post/" title="Posts page">
              Posts
            </a>
          </li>
          
        </ul>
      
      












    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">

    <header class="mt4 w-100">
      <p class="f6 b helvetica tracked">
          
        POSTS
      </p>
      <h1 class="f1 athelas mb1">Flannel源码分析</h1>
      
      
      <time class="f6 mv4 dib tracked" datetime="2019-09-12T16:59:05&#43;08:00">September 12, 2019</time>
      
      
    </header>

    <section class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l">

<h1 id="flannel源码分析">Flannel源码分析</h1>

<h2 id="前言">前言</h2>

<p>flannel作为kubernetes的一种网络解决方案，在社区是比较活跃的。支持多种backend。</p>

<p>flannel源码地址在：<a href="https://github.com/coreos/flannel">https://github.com/coreos/flannel</a></p>

<p>从官网上把flannel的代码clone下来，目录结构如下：</p>

<pre><code class="language-shell">$ ll -ah
total 222K
drwxr-xr-x 1 user 197121    0 8月  30 18:37 ./
drwxr-xr-x 1 user 197121    0 8月  30 18:31 ../
-rw-r--r-- 1 user 197121  351 8月  30 18:33 .appveyor.yml
-rw-r--r-- 1 user 197121   56 8月  30 18:33 .dockerignore
drwxr-xr-x 1 user 197121    0 9月  17 09:34 .git/
drwxr-xr-x 1 user 197121    0 8月  30 18:33 .github/
-rw-r--r-- 1 user 197121  147 8月  30 18:33 .gitignore
drwxr-xr-x 1 user 197121    0 9月  17 11:22 .idea/
-rw-r--r-- 1 user 197121  411 8月  30 18:33 .travis.yml
drwxr-xr-x 1 user 197121    0 8月  30 18:33 backend/
-rw-r--r-- 1 user 197121 3.7K 8月  30 18:33 bill-of-materials.json
-rw-r--r-- 1 user 197121   98 8月  30 18:33 bill-of-materials.override.json
-rw-r--r-- 1 user 197121 3.1K 8月  30 18:33 code-of-conduct.md
-rw-r--r-- 1 user 197121 2.5K 8月  30 18:33 CONTRIBUTING.md
-rw-r--r-- 1 user 197121 1.5K 8月  30 18:33 DCO
drwxr-xr-x 1 user 197121    0 8月  30 18:33 dist/
-rw-r--r-- 1 user 197121  427 8月  30 18:33 Dockerfile.amd64
-rw-r--r-- 1 user 197121  504 8月  30 18:33 Dockerfile.arm
-rw-r--r-- 1 user 197121  494 8月  30 18:33 Dockerfile.arm64
-rw-r--r-- 1 user 197121  508 8月  30 18:33 Dockerfile.ppc64le
-rw-r--r-- 1 user 197121  504 8月  30 18:33 Dockerfile.s390x
drwxr-xr-x 1 user 197121    0 8月  30 18:33 Documentation/
-rw-r--r-- 1 user 197121  11K 8月  30 18:33 glide.lock
-rw-r--r-- 1 user 197121 1.6K 8月  30 18:33 glide.yaml
-rwxr-xr-x 1 user 197121  298 8月  30 18:33 header-check.sh*
drwxr-xr-x 1 user 197121    0 8月  30 18:33 images/
-rw-r--r-- 1 user 197121  12K 8月  30 18:33 LICENSE
drwxr-xr-x 1 user 197121    0 8月  30 18:33 logos/
-rw-r--r-- 1 user 197121  21K 8月  30 18:33 main.go
-rw-r--r-- 1 user 197121   98 8月  30 18:33 MAINTAINERS
-rw-r--r-- 1 user 197121  12K 8月  30 18:33 Makefile
drwxr-xr-x 1 user 197121    0 8月  30 18:33 network/
-rw-r--r-- 1 user 197121  131 8月  30 18:33 NOTICE
-rw-r--r-- 1 user 197121  212 8月  30 18:33 OWNERS
-rw-r--r-- 1 user 197121  75K 8月  30 18:33 packet-01.png
drwxr-xr-x 1 user 197121    0 8月  30 18:33 pkg/
-rw-r--r-- 1 user 197121 4.3K 8月  30 18:33 README.md
drwxr-xr-x 1 user 197121    0 8月  30 18:33 subnet/
drwxr-xr-x 1 user 197121    0 8月  30 18:33 vendor/
drwxr-xr-x 1 user 197121    0 8月  30 18:33 version/
</code></pre>

<p>这里介绍几个主要目录的用途：</p>

<ul>
<li>backend，flannel支持多种flannel，比如host-gw、vxlan等</li>
<li>dist，一些脚本和dockerfile文件</li>
<li>network，对主机的iptables进行操作</li>
<li>pkg，外部可引用的包</li>
<li>subnet，flannel中每个host对应一个subnet</li>
<li>./main.go，flannel程序的入口</li>
</ul>

<p>经过上述分析，分析flannel的源代码就从./main.go文件入手。</p>

<h2 id="1-参数解析">1.参数解析</h2>

<p>./main.go中结构体CmdLineOpts包含了所有命令行传入的参数解析，具体如下：</p>

<pre><code class="language-go">type CmdLineOpts struct {
	etcdEndpoints          string
	etcdPrefix             string
	etcdKeyfile            string
	etcdCertfile           string
	etcdCAFile             string
	etcdUsername           string
	etcdPassword           string
    // 上述的etcd参数，指的是如果采用etcd作为后端subnet存储的话，要提供上述etcd连接参数
	help                   bool
	version                bool
    // 帮助和打印出version
	kubeSubnetMgr          bool
    // 如果上述kubeSubnetMgr为true，则使用kube-apiserver为subnet的后端存储（其实是将每个node的subnet信息存入到了node的annotations中）
	kubeApiUrl             string
	kubeAnnotationPrefix   string
	kubeConfigFile         string
    // 上述三个kube相关的参数标识连接kube-apiserver的必要参数
	iface                  flagSlice
	ifaceRegex             flagSlice
    // iface参数，用来作为多节点通信的网卡，不指定的话，flannel会使用默认网卡和其上IP信息
	ipMasq                 bool
    // ipMasq （具体意义待定）
	subnetFile             string
    // 存储subnet的文件，默认为/run/flannel/subnet.env，其中存储了整个集群的pod subnet段，本机上pod的subnet段等信息
	subnetDir              string
	publicIP               string
    // 用来跨节点通信的IP地址，和上述iface参数类似
	subnetLeaseRenewMargin int
    // subnet是以lease（租约）的形式存储起来的，到期会自动过期。需要定时续租，改时间表示在lease过期前多少时间续租，单位是min，默认值是60
	healthzIP              string
	healthzPort            int
    // 用来健康检查的IP和PORT
	charonExecutablePath   string
	charonViciUri          string
	iptablesResyncSeconds  int
    // 同步iptables规则的时间间隔。默认5s同步一次
	iptablesForwardRules   bool
    // add default accept rules to FORWARD chain in iptables
	netConfPath            string
    // networkConfiguration PATH
}
</code></pre>

<p>main.go中首先是init函数对命令行传入参数进行赋值，没有赋值的采用默认值。然后进到main()函数中。</p>

<h2 id="2-main函数结构">2.main函数结构</h2>

<p>首先看一下main函数的主要结构，然后分步分析：</p>

<pre><code class="language-go">func main() {
	// 如果是打印版本，则打印退出
	if opts.version {
		fmt.Fprintln(os.Stderr, version.Version)
		os.Exit(0)
	}

	flagutil.SetFlagsFromEnv(flannelFlags, &quot;FLANNELD&quot;)

	// Validate flags
    // 验证参数，如果续租时间大于24*60或者小于等于0，则直接报错。
    // 因为默认的租约时间为24*60
	if opts.subnetLeaseRenewMargin &gt;= 24*60 || opts.subnetLeaseRenewMargin &lt;= 0 {
		log.Error(&quot;Invalid subnet-lease-renew-margin option, out of acceptable range&quot;)
		os.Exit(1)
	}
    
    // Work out which interface to use
    // 找出externalInterface，很简单，如果命令行参数指定了使用哪个网卡，则直接使用，若没指定，则需要自己去找默认的网卡，主要是LookupExtIface这个函数来寻找。这个函数中所调用的ip.GetDefaultGatewayIface()是位于pkg目录下，在自己写程序来获取linux主机默认网卡和ip信息的时候也可以直接引用该函数
	var extIface *backend.ExternalInterface
	var err error
	// Check the default interface only if no interfaces are specified
	if len(opts.iface) == 0 &amp;&amp; len(opts.ifaceRegex) == 0 {
		extIface, err = LookupExtIface(&quot;&quot;, &quot;&quot;)
		if err != nil {
			log.Error(&quot;Failed to find any valid interface to use: &quot;, err)
			os.Exit(1)
		}
	} else {
		// Check explicitly specified interfaces
		for _, iface := range opts.iface {
			extIface, err = LookupExtIface(iface, &quot;&quot;)
			if err != nil {
				log.Infof(&quot;Could not find valid interface matching %s: %s&quot;, iface, err)
			}

			if extIface != nil {
				break
			}
		}

		// Check interfaces that match any specified regexes
		if extIface == nil {
			for _, ifaceRegex := range opts.ifaceRegex {
				extIface, err = LookupExtIface(&quot;&quot;, ifaceRegex)
				if err != nil {
					log.Infof(&quot;Could not find valid interface matching %s: %s&quot;, ifaceRegex, err)
				}

				if extIface != nil {
					break
				}
			}
		}

		if extIface == nil {
			// Exit if any of the specified interfaces do not match
			log.Error(&quot;Failed to find interface to use that matches the interfaces and/or regexes provided&quot;)
			os.Exit(1)
		}
	}
    
    // 第一步：创建SubnetManager，主要是用来管理subnet的。
    sm, err := newSubnetManager()
	if err != nil {
		log.Error(&quot;Failed to create SubnetManager: &quot;, err)
		os.Exit(1)
	}
	log.Infof(&quot;Created subnet manager: %s&quot;, sm.Name())
    
    // 下述这段代码是控制程序优雅退出的，首先是创建了sigs channel，类型为os.Signal,buffer为1.
    // 此处两个golang的用法，第一个是context，第二个是sync.waitGroup
    // Register for SIGINT and SIGTERM
	log.Info(&quot;Installing signal handlers&quot;)
	sigs := make(chan os.Signal, 1)
	signal.Notify(sigs, os.Interrupt, syscall.SIGTERM)

	// This is the main context that everything should run in.
	// All spawned goroutines should exit when cancel is called on this context.
	// Go routines spawned from main.go coordinate using a WaitGroup. This provides a mechanism to allow the shutdownHandler goroutine
	// to block until all the goroutines return . If those goroutines spawn other goroutines then they are responsible for
	// blocking and returning only when cancel() is called.
	// 创建全局的ctx
    ctx, cancel := context.WithCancel(context.Background())
	
    // 创建任务
    wg := sync.WaitGroup{}

   // 添加一个任务
	wg.Add(1)
	go func() {
        // shutdownHander中如果监听到系统信号，则调用cancel函数，那么所有的调用都将终止
		shutdownHandler(ctx, sigs, cancel)
		wg.Done()
	}()
    
    // 如果定义了健康检查端口，则要启动一个http服务监听该端口
    if opts.healthzPort &gt; 0 {
		// It's not super easy to shutdown the HTTP server so don't attempt to stop it cleanly
		go mustRunHealthz()
	}
    
    // 第二步：创建backend，并且通过该backend来注册subnet
    // Create a backend manager then use it to create the backend and register the network with it.
	bm := backend.NewManager(ctx, sm, extIface)
	be, err := bm.GetBackend(config.BackendType)
	if err != nil {
		log.Errorf(&quot;Error fetching backend: %s&quot;, err)
		cancel()
		wg.Wait()
		os.Exit(1)
	}

    // 注册subnet
	bn, err := be.RegisterNetwork(ctx, wg, config)
	if err != nil {
		log.Errorf(&quot;Error registering network: %s&quot;, err)
		cancel()
		wg.Wait()
		os.Exit(1)
	}
    
    // 第三步：如果指定了ipMasq，则定期同步iptables
    // Set up ipMasq if needed
	if opts.ipMasq {
		if err = recycleIPTables(config.Network, bn.Lease()); err != nil {
			log.Errorf(&quot;Failed to recycle IPTables rules, %v&quot;, err)
			cancel()
			wg.Wait()
			os.Exit(1)
		}
		log.Infof(&quot;Setting up masking rules&quot;)
		go network.SetupAndEnsureIPTables(network.MasqRules(config.Network, bn.Lease()), opts.iptablesResyncSeconds)
	}
    
    // 第四步：iptablesForwardRules指定的话，定期去同步指定的iptables
    // Always enables forwarding rules. This is needed for Docker versions &gt;1.13 (https://docs.docker.com/engine/userguide/networking/default_network/container-communication/#container-communication-between-hosts)
	// In Docker 1.12 and earlier, the default FORWARD chain policy was ACCEPT.
	// In Docker 1.13 and later, Docker sets the default policy of the FORWARD chain to DROP.
	if opts.iptablesForwardRules {
		log.Infof(&quot;Changing default FORWARD chain policy to ACCEPT&quot;)
		go network.SetupAndEnsureIPTables(network.ForwardRules(config.Network.String()), opts.iptablesResyncSeconds)
	}
    
    // 第五步：写入subnet file
    if err := WriteSubnetFile(opts.subnetFile, config.Network, opts.ipMasq, bn); err != nil {
		// Continue, even though it failed.
		log.Warningf(&quot;Failed to write subnet file: %s&quot;, err)
	} else {
		log.Infof(&quot;Wrote subnet file to %s&quot;, opts.subnetFile)
	}
    
    // 第六步：backend run起来
    // Start &quot;Running&quot; the backend network. This will block until the context is done so run in another goroutine.
	log.Info(&quot;Running backend.&quot;)
	wg.Add(1)
	go func() {
		bn.Run(ctx)
		wg.Done()
	}()
    
    // 第七步：kube subnet mgr监听subnet lease
    // Kube subnet mgr doesn't lease the subnet for this node - it just uses the podCidr that's already assigned.
	if !opts.kubeSubnetMgr {
		err = MonitorLease(ctx, sm, bn, &amp;wg)
		if err == errInterrupted {
			// The lease was &quot;revoked&quot; - shut everything down
			cancel()
		}
	}

    
    log.Info(&quot;Waiting for all goroutines to exit&quot;)
	// Block waiting for all the goroutines to finish.
	wg.Wait()
	log.Info(&quot;Exiting cleanly...&quot;)
	os.Exit(0)
    
</code></pre>

<p>上述main函数中列出了7个主要的步骤，下面依次分析。</p>

<h2 id="3-第一步-创建subnetmanager">3.第一步：创建SubnetManager</h2>

<p>main.go中的newSubnetManager函数：</p>

<pre><code class="language-go">func newSubnetManager() (subnet.Manager, error) {
	if opts.kubeSubnetMgr {
		return kube.NewSubnetManager(opts.kubeApiUrl, opts.kubeConfigFile, opts.kubeAnnotationPrefix, opts.netConfPath)
	}

	cfg := &amp;etcdv2.EtcdConfig{
		Endpoints: strings.Split(opts.etcdEndpoints, &quot;,&quot;),
		Keyfile:   opts.etcdKeyfile,
		Certfile:  opts.etcdCertfile,
		CAFile:    opts.etcdCAFile,
		Prefix:    opts.etcdPrefix,
		Username:  opts.etcdUsername,
		Password:  opts.etcdPassword,
	}

	// Attempt to renew the lease for the subnet specified in the subnetFile
	prevSubnet := ReadCIDRFromSubnetFile(opts.subnetFile, &quot;FLANNEL_SUBNET&quot;)

	return etcdv2.NewLocalManager(cfg, prevSubnet)
}
</code></pre>

<p>如果使用了kubeSubnetMgr，则调用kube.NewSubnetManager，否则调用etcdv2。这一点需要说明的是etcd发展到现在支持不同的版本，v2和v3，且v3版本具有很多优势。flannel仓库中v2版本相关的代码提交是2 years之前，因此可见目前flannel实际上只支持kube-apiserver作为后端存储，也是默认的存储方式。</p>

<p>./flannel/subnet/kube/kube.go：</p>

<pre><code class="language-go">type kubeSubnetManager struct {
	// 往node的yaml文件中添加的annotations
	annotations    annotations
	// 与kube-apiserver交互的client
	client         clientset.Interface
    // 运行在哪个node上
	nodeName       string
    // node lister
	nodeStore      listers.NodeLister
    // node controller
	nodeController cache.Controller
	subnetConf     *subnet.Config
	events         chan subnet.Event
}
</code></pre>

<p>下面进入flannel/subnet/kube/kube.go里的NewSubnetManager函数中，看看都干了啥：</p>

<pre><code class="language-go">func NewSubnetManager(apiUrl, kubeconfig, prefix, netConfPath string) (subnet.Manager, error) {
	//先看看入参函数：kube-apiserver的地址，kubeconfig的地址，prefix是给node打anno的时候前缀，netConfPath是配置存储目录，实际上安装完成之后，是通过configmap的形式挂载到/etc/kube-flannel/net-conf.json里的
	var cfg *rest.Config
	var err error
	// Try to build kubernetes config from a master url or a kubeconfig filepath. If neither masterUrl
	// or kubeconfigPath are passed in we fall back to inClusterConfig. If inClusterConfig fails,
	// we fallback to the default config.
	cfg, err = clientcmd.BuildConfigFromFlags(apiUrl, kubeconfig)
	if err != nil {
		return nil, fmt.Errorf(&quot;fail to create kubernetes config: %v&quot;, err)
	}

	c, err := clientset.NewForConfig(cfg)
	if err != nil {
		return nil, fmt.Errorf(&quot;unable to initialize client: %v&quot;, err)
	}
    // 上述是通过提供的配置，创建clientset，用来连接kube-apiserver

	// The kube subnet mgr needs to know the k8s node name that it's running on so it can annotate it.
	// If we're running as a pod then the POD_NAME and POD_NAMESPACE will be populated and can be used to find the node
	// name. Otherwise, the environment variable NODE_NAME can be passed in.
	// 获取nodename
    nodeName := os.Getenv(&quot;NODE_NAME&quot;)
	if nodeName == &quot;&quot; {
		podName := os.Getenv(&quot;POD_NAME&quot;)
		podNamespace := os.Getenv(&quot;POD_NAMESPACE&quot;)
		if podName == &quot;&quot; || podNamespace == &quot;&quot; {
			return nil, fmt.Errorf(&quot;env variables POD_NAME and POD_NAMESPACE must be set&quot;)
		}

		pod, err := c.Pods(podNamespace).Get(podName, metav1.GetOptions{})
		if err != nil {
			return nil, fmt.Errorf(&quot;error retrieving pod spec for '%s/%s': %v&quot;, podNamespace, podName, err)
		}
		nodeName = pod.Spec.NodeName
		if nodeName == &quot;&quot; {
			return nil, fmt.Errorf(&quot;node name not present in pod spec '%s/%s'&quot;, podNamespace, podName)
		}
	}

    // 读取网络配置文件
	netConf, err := ioutil.ReadFile(netConfPath)
	if err != nil {
		return nil, fmt.Errorf(&quot;failed to read net conf: %v&quot;, err)
	}

    // 解析网络配置
	sc, err := subnet.ParseConfig(string(netConf))
	if err != nil {
		return nil, fmt.Errorf(&quot;error parsing subnet config: %s&quot;, err)
	}

    // 初始化并运行subnetManager，传入的参数有clientset，网络配置，nodename，anno前缀，具体的new和Run函数下文分析
	sm, err := newKubeSubnetManager(c, sc, nodeName, prefix)
	if err != nil {
		return nil, fmt.Errorf(&quot;error creating network manager: %s&quot;, err)
	}
	go sm.Run(context.Background())

    // 下面确保hasSynced
	glog.Infof(&quot;Waiting %s for node controller to sync&quot;, nodeControllerSyncTimeout)
	err = wait.Poll(time.Second, nodeControllerSyncTimeout, func() (bool, error) {
		return sm.nodeController.HasSynced(), nil
	})
	if err != nil {
		return nil, fmt.Errorf(&quot;error waiting for nodeController to sync state: %v&quot;, err)
	}
	glog.Infof(&quot;Node controller sync successful&quot;)

	return sm, nil
}
</code></pre>

<p>下面去看看如何newKubeSubnetManager和让其Run起来的。</p>

<pre><code class="language-go">func newKubeSubnetManager(c clientset.Interface, sc *subnet.Config, nodeName, prefix string) (*kubeSubnetManager, error) {
   var err error
   var ksm kubeSubnetManager
   ksm.annotations, err = newAnnotations(prefix)
   if err != nil {
      return nil, err
   }
   ksm.client = c
   ksm.nodeName = nodeName
   ksm.subnetConf = sc
   ksm.events = make(chan subnet.Event, 5000)
   indexer, controller := cache.NewIndexerInformer(
      &amp;cache.ListWatch{
         ListFunc: func(options metav1.ListOptions) (runtime.Object, error) {
            return ksm.client.CoreV1().Nodes().List(options)
         },
         WatchFunc: func(options metav1.ListOptions) (watch.Interface, error) {
            return ksm.client.CoreV1().Nodes().Watch(options)
         },
      },
      &amp;v1.Node{},
      resyncPeriod,
      cache.ResourceEventHandlerFuncs{
         AddFunc: func(obj interface{}) {
            ksm.handleAddLeaseEvent(subnet.EventAdded, obj)
         },
         UpdateFunc: ksm.handleUpdateLeaseEvent,
         DeleteFunc: func(obj interface{}) {
            node, isNode := obj.(*v1.Node)
            // We can get DeletedFinalStateUnknown instead of *api.Node here and we need to handle that correctly.
            if !isNode {
               deletedState, ok := obj.(cache.DeletedFinalStateUnknown)
               if !ok {
                  glog.Infof(&quot;Error received unexpected object: %v&quot;, obj)
                  return
               }
               node, ok = deletedState.Obj.(*v1.Node)
               if !ok {
                  glog.Infof(&quot;Error deletedFinalStateUnknown contained non-Node object: %v&quot;, deletedState.Obj)
                  return
               }
               obj = node
            }
            ksm.handleAddLeaseEvent(subnet.EventRemoved, obj)
         },
      },
      cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc},
   )
   ksm.nodeController = controller
   ksm.nodeStore = listers.NewNodeLister(indexer)
   return &amp;ksm, nil
}
</code></pre>

<p>总结一下上述函数都干了啥：</p>

<ul>
<li>初始化kubeSubnetManager</li>
<li>ksm主要是对集群中node进行监听，因为flannel是根据node来划分网段的</li>
<li>根据监听到的node的事件，放入到ksm的events channel中</li>
</ul>

<p>此外，ksm.Run函数就是运行起来。</p>

<h2 id="4-第二步-创建backend">4.第二步：创建backend</h2>

<p>首先看backend/manager.go中的NewManager函数</p>

<pre><code class="language-go">func NewManager(ctx context.Context, sm subnet.Manager, extIface *ExternalInterface) Manager {
   return &amp;manager{
      ctx:      ctx,
      sm:       sm,
      extIface: extIface,
      active:   make(map[string]Backend),
   }
}
</code></pre>

<p>只是返回了一个manager对象：</p>

<pre><code class="language-go">type manager struct {
   ctx      context.Context
    // 上文创建好的ksm
   sm       subnet.Manager
    // 用来与外界通信的interface
   extIface *ExternalInterface
    // 互斥锁
   mux      sync.Mutex
   active   map[string]Backend
   wg       sync.WaitGroup
}
</code></pre>

<p>下面看bm.GetBackend(config.BackendType)函数：</p>

<pre><code class="language-go">func (bm *manager) GetBackend(backendType string) (Backend, error) {
    //传入的参数是config的BackendType，此配置项是通过configmap写入到flannel的pod中的，因此是一个固定的值，比如vxlan
   bm.mux.Lock()
   defer bm.mux.Unlock()

   betype := strings.ToLower(backendType)
   // see if one is already running
   if be, ok := bm.active[betype]; ok {
      return be, nil
   }

   // first request, need to create and run it
   befunc, ok := constructors[betype]
   if !ok {
      return nil, fmt.Errorf(&quot;unknown backend type: %v&quot;, betype)
   }

   be, err := befunc(bm.sm, bm.extIface)
   if err != nil {
      return nil, err
   }
   bm.active[betype] = be

   bm.wg.Add(1)
   go func() {
      &lt;-bm.ctx.Done()

      // TODO(eyakubovich): this obviosly introduces a race.
      // GetBackend() could get called while we are here.
      // Currently though, all backends' Run exit only
      // on shutdown

      bm.mux.Lock()
      delete(bm.active, betype)
      bm.mux.Unlock()

      bm.wg.Done()
   }()

   return be, nil
}
</code></pre>

<p>main.go的289行bn, err := be.RegisterNetwork(ctx, wg, config)，实际上调用的是具体的backend的Register，比如配置了vxlan就调用vxlan的register：</p>

<p>flannel/backend/vxlan/vxlan.go:</p>

<pre><code class="language-go">func (be *VXLANBackend) RegisterNetwork(ctx context.Context, wg sync.WaitGroup, config *subnet.Config) (backend.Network, error) {
   // Parse our configuration
   cfg := struct {
      VNI           int
      Port          int
      GBP           bool
      Learning      bool
      DirectRouting bool
   }{
      VNI: defaultVNI,
   }

   if len(config.Backend) &gt; 0 {
      if err := json.Unmarshal(config.Backend, &amp;cfg); err != nil {
         return nil, fmt.Errorf(&quot;error decoding VXLAN backend config: %v&quot;, err)
      }
   }
   log.Infof(&quot;VXLAN config: VNI=%d Port=%d GBP=%v Learning=%v DirectRouting=%v&quot;, cfg.VNI, cfg.Port, cfg.GBP, cfg.Learning, cfg.DirectRouting)

   devAttrs := vxlanDeviceAttrs{
      vni:       uint32(cfg.VNI),
      name:      fmt.Sprintf(&quot;flannel.%v&quot;, cfg.VNI),
      vtepIndex: be.extIface.Iface.Index,
      vtepAddr:  be.extIface.IfaceAddr,
      vtepPort:  cfg.Port,
      gbp:       cfg.GBP,
      learning:  cfg.Learning,
   }

   dev, err := newVXLANDevice(&amp;devAttrs)
   if err != nil {
      return nil, err
   }
   dev.directRouting = cfg.DirectRouting

   subnetAttrs, err := newSubnetAttrs(be.extIface.ExtAddr, dev.MACAddr())
   if err != nil {
      return nil, err
   }

   lease, err := be.subnetMgr.AcquireLease(ctx, subnetAttrs)
   switch err {
   case nil:
   case context.Canceled, context.DeadlineExceeded:
      return nil, err
   default:
      return nil, fmt.Errorf(&quot;failed to acquire lease: %v&quot;, err)
   }

   // Ensure that the device has a /32 address so that no broadcast routes are created.
   // This IP is just used as a source address for host to workload traffic (so
   // the return path for the traffic has an address on the flannel network to use as the destination)
   if err := dev.Configure(ip.IP4Net{IP: lease.Subnet.IP, PrefixLen: 32}); err != nil {
      return nil, fmt.Errorf(&quot;failed to configure interface %s: %s&quot;, dev.link.Attrs().Name, err)
   }

   return newNetwork(be.subnetMgr, be.extIface, dev, ip.IP4Net{}, lease)
}
</code></pre>

<p>该函数主要是创建vxlan设备。配置对应的路由，给vxlan设备配置IP信息等等。</p>
<ul class="pa0">
  
</ul>
<div class="mt6">
      
        <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "qsyqian" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
      
      <div id="commento"></div>
<script defer src="https://cdn.commento.io/js/commento.js"></script>

      </div>
    </section>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://qsyqian.github.io/" >
    &copy;  qianshuangyang 2019 
  </a>
    <div>











</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
